{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction The Policy Machine is a reference implementation of the Next Generation Access Control (NGAC) standard. Provided is a Java library to model and query NGAC graphs and a RESTful API for an administrative Policy Enforcement Point (PEP). The API that can be used to create NGAC aware applications.","title":"Introduction"},{"location":"#introduction","text":"The Policy Machine is a reference implementation of the Next Generation Access Control (NGAC) standard. Provided is a Java library to model and query NGAC graphs and a RESTful API for an administrative Policy Enforcement Point (PEP). The API that can be used to create NGAC aware applications.","title":"Introduction"},{"location":"api/","text":"REST API What is the Purpose of the API? The Policy Machine REST API exposes a standard set of administrative NGAC commands. This API also acts as a Policy Enforcement Point (PEP) by ensuring any calling user has permission to carry out a command before any action is taken. Exposing the PEP allows users to create web-based, NGAC aware applications. Important Notes Super user metadata - There are 7 nodes that make up the super user metadata. The super user is assigned to 2 User Attributes super_ua1 and super_ua2. These two attributes are assigned to a Policy Class also called super. Super_ua1 is associated with an Object Attribute, super_oa1, which is also assigned to the Policy Class super, with * permissions. This gives any user in super_ua1 all permissions on objects in super_oa1. There is one Object called super assigned to super_oa1. Super_ua2 is associated with super_ua1 with * permissions. This allows the super user to have all permissions on itself as well. Creating a Policy Class - When creating a Policy Class we check if the requesting user has the permission \"create a Policy Class\" on the super object. Policy Class assignments - When a Policy Class is created, an Object Attribute that will represent the Policy Class is also created, and assigned to super_oa1. The representative will be used any time a user is assigning to or deassigning from the Policy Class. This allows us to control who can perform these actions since Policy Classes them selves cannot be assigned or associated to any other nodes. Deployment Run Docker Compose Build the war file by running mvn clean package install from the project root. This will create pm.war in the project's /target/ directory. Run docker-compose up from the project root to start the docker container. Docker Compose File version: '3' services: neo4j: image: neo4j:latest volumes: - $HOME/neo4j/data:/data - $HOME/neo4j/logs:/logs ports: - 7474:7474 - 7687:7687 pm: image: tomcat:8-jre8 volumes: - ./target/pm.war:/usr/local/tomcat/webapps/pm.war ports: - 8080:8080 links: - neo4j The Compose file creates two linked containers. A Neo4j container which is where we will store our access control policy data. We expose the ports 7474 and 7687 to interact with the Neo4j database. The tomcat server that will deploy pm.war . Tested Operating Systems macOS Docker for Mac Windows 7 Docker Toolbox Note : Docker Toolbox is legacy software and handles volumes differently than Docker for Windows/Mac. There is one line in the Docker Compose file that needs to be updated. Create a shared folder in Oracle VirtualBox called /target/ which points to the target folder of the PM project. change this line in the Compose file: ./target/pm.war:/usr/local/tomcat/webapps/pm.war to //target/pm.war:/usr/local/tomcat/webapps/pm.war How to Use the API Requests The exposed web services act as an administrative Policy Enforcement Point (PEP). When a request comes in the PEP forwards the request to the PDP, which ensures the requesting user is allowed to carry out the action. This means the PEP always needs to know which user is sending a request. This is tracked using session IDs that represent users who have authenticated successfully with the server. Every endpoint requires this session ID to determine the user. The only API that does not require a session ID is the Sessions API. This API is used to authenticate users and provides the session IDs that will be used in subsequent requests to the Policy Machine. For example, to sign in as the super user: POST /pm/api/sessions Content-Type:application/json { \"username\": \"super\", \"password\": \"super\" } The response from the server will look like: { \"code\": 9000, \"message\": \"success\", \"entity\": \"NEW_SESSION_ID\" } Now the user can pass this session ID to the server for any other calls to the API. Responses A response from the Policy Machine will always return an HTTP status code of 200, with more details provided in the body of the response. For example: { \"code\": 9000, \"message\": \"success\", \"entity\": \"return value of the API call\" } Response codes Sessions API Create session Authenticate the provided credentials and return a session ID if successfully authenticated. Endpoint POST /pm/api/sessions Parameters Parameter Required Location Description username required body The username of the user password required body The password of the user Example request $ curl -X POST {host}:{port}/pm/api/sessions Example request body { \"username\": \"super\", \"password\": \"super\" } Example response { \"code\": 9000, \"message\": \"success\", \"entity\": \"{sessionID}\" } Delete session Delete the session with the given session ID. Endpoint DELETE /pm/api/sessions/{sessionID} Example request $ curl -X DELETE {host}:{port}/pm/api/sessions/{sessionID} Example response { \"code\": 9000, \"message\": \"success\", \"entity\": \"session deleted\" } Get session user Get the ID of the user that corresponds with the provided session ID. Endpoint GET /pm/api/sessions/{sessionID} Example request $ curl {host}:{port}/pm/api/sessions/{sessionID} Example response { \"code\": 9000, \"message\": \"success\", \"entity\": 1234 } Graph API Get nodes Retrieve nodes from the graph. Use query parameters to filter nodes based on name, type, or any other properties nodes may have. The returned set of nodes will only contain those the user, identified by the session parameter, has access to. Endpoint GET /pm/api/graph/nodes Parameters Parameter Required Location Description session true query The ID of the current session. name false query The name of the nodes to search for. type false query The type of the nodes to search for. Important Notes The name and type query parameters are the only preset parameters to search for. It is possible to search for nodes with any property key value pair by including the pair in the query parameters of the request. For example, ?key1=value1&key2=value2 . Only nodes that match every provided property will be returned. To search for all nodes that have a specfic property key but an arbitrary value use the wildcard * . For example, key3=* . Example request $ curl {host}:{port}/pm/api/graph/nodes?session={sessionID}&type=OA Example response { \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"node1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"node2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] } Create node Create a new node in the NGAC graph with the provided name, type, and properties. When creating a Policy Class, leave the baseID parameter empty, as it will be ignored. For all other node type, a base ID is required in order to connect the node to the graph and ensure the calling user (identified by the provided session ID) has the permission to create a node in the base node (check that the user can assign to the base node). Endpoint POST /pm/api/graph/nodes Parameters Parameter Required Location Description session true query The ID of the current session. parentID false body The ID of the node to assign the new node to. name true body The name of the node. type true body The type of the node. properties true body A map of properties to give the node. Example request $ curl -X POST {host}:{port}/pm/api/graph/nodes?session={sessionID} Example request body { \"name\": \"newNode\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\", \"key2\": \"value2\" } } Example response { \"code\": 9000, \"message\": \"success\", \"entity\": 12345 } Get node Retrieve the information for a node identified by the given ID. Endpoint GET /pm/api/graph/nodes/{nodeID} Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to retrieve. Example request $ curl {host}:{port}/pm/api/graph/nodes/12345678?session={sessionID} Example response { \"code\": 9000, \"message\": \"success\", \"entity\": { \"id\": 12345678, \"name\": \"newNode\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\", \"key2\": \"value2\" } } } Update node Update the name and/or properties of a node with the given ID. The properties provided in the parameters will overwrite existing properties. Endpoint UPDATE /pm/api/graph/nodes/{nodeID} Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to update. name false body The updated name. properties false body The properties to override the existing properties of the node. Example request $ curl -X PUT {host}:{port}/pm/api/graph/nodes/12345?session={sessionID} Example request body { \"name\": \"updated_name\", \"properties\": { \"key3\": \"value3\", } } Example response { \"code\": 9000, \"message\": \"Node was successfully updated\", \"entity\": null } Delete node Delete the node with the given ID. The calling user must have permission to delete the node in order for the action to successfully be carried out. Endpoint DELETE /pm/api/graph/nodes/{nodeID} Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to delete. Example request $ curl -X DELETE {host}:{port}/pm/api/graph/nodes/12345?session={sessionID} Example response { \"code\": 9000, \"message\": \"Node successfully deleted\", \"entity\": null } Get node children Get the nodes that are assigned to the node with the given ID. The method will return only the children the calling user has access to. Endpoint GET /pm/api/graph/nodes/{nodeID}/children Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the children of. Example request $ curl {host}:{port}/pm/api/graph/nodes/{nodeID}/children?session={sessionID} Example response { \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"child1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"child2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] } Get node parents Get the nodes that a node is assigned to. Only the parents that the calling user has access to will be returned. Endpoint GET /pm/api/graph/nodes/{nodeID}/parents Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the parents of. Example request $ curl {host}:{port}/pm/api/graph/nodes/1234/parents?session={sessionID} Example response { \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"parent1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"parent2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] } Create assignment Create an assignment between two nodes. An assignment must not already exist between the nodes, and the types of the nodes must make a valid assignment. child parent PC OA OA, PC UA UA, PC O OA u UA ###### Endpoint POST /pm/api/graph/{child}/assignments/{parent} ###### Parameters Parameter Required --- --- session true child true parent true Example request $ curl -X POST {host}:{port}/pm/api/graph/child;id=1234;type=OA/assignments/parent;id=4321;type=OA?session={sessionID} Example response { \"code\": 9000, \"message\": \"Assignment successfully created\", \"entity\": null } Delete assignment Delete an assignment between two nodes, as long as the calling user has permissions to do so. If an assignment does not exist between the two nodes, nothing will happen and a success code will be returned. Endpoint DELETE /pm/api/graph/{childID}/assignments/{parentID} Parameters Parameter | Required | Location | Description | Example ---|---|---|--- session | true | query | The ID of the current session. | child | true | body | The ID of the child node and a martix parameter for the type. | child;id=1234;type=OA parent | true | body | The ID of the parent node and a matrix parameter for the type. | parent;id=4321;type=OA Example request $ curl -X DELETE {host}:{port}/pm/api/graph/child;id=1234;type=OA/assignments/parent;id=4321;type=OA?session={sessionID} Example response { \"code\": 9000, \"message\": \"Assignment successfully deleted\", \"entity\": null } Get associations Get the associations the given node is apart of. The node must exist in the graph. The query parameter type is required and denotes which type of associations to retrieve for the node. Accepted values are source and target . Source will get the associations the given node is the source of. Target will get the associations the given node is a target of. Endpoint GET /pm/api/graph/{nodeID}/associations Parameters Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the associations for. type true query Either source or target . Example request $ curl {host}:{port}/pm/api/graph/101?session={sessionID}&type=source Example response { \"1234\": [ \"read\", \"write\" ], \"4321\": [ \"read\" ] } Create association Create an association between a user attribute and a target node. The user attribute and target nodes need to already exist in the graph. The target node can be another user attribute or an object attribute. The target segment of the request url must contain the ID and type of the intended target node. Endpoint POST /pm/api/graph/{uaID}/associations/{target} Parameters Parameter Required Location Description session true query The ID of the current session. uaID true path The ID of the User Attribute. target true path The target of the association. The ID and Type are required matrix parameters. operations false body The set of operations to give the association. Example request $ curl {host}:{port}/pm/api/graph/1234/associations/target;id=4321;type=OA?session={sessionID} Example request body { \"operations\": [ \"read\", \"write\" ] } Example response { \"code\": 9000, \"message\": \"Association successfully created\", \"entity\": null } Update association Endpoint GET /pm/api/graph/nodes Parameters Parameter Required Location Description session true query The ID of the current session. Example request $ curl {host}:{port}/pm/api/graph/nodes?session={sessionID} Example response Delete association Endpoint GET /pm/api/graph/nodes Parameters Parameter Required Location Description session true query The ID of the current session. Example request $ curl {host}:{port}/pm/api/graph/nodes?session={sessionID} Example response","title":"REST API"},{"location":"api/#rest-api","text":"","title":"REST API"},{"location":"api/#what-is-the-purpose-of-the-api","text":"The Policy Machine REST API exposes a standard set of administrative NGAC commands. This API also acts as a Policy Enforcement Point (PEP) by ensuring any calling user has permission to carry out a command before any action is taken. Exposing the PEP allows users to create web-based, NGAC aware applications.","title":"What is the Purpose of the API?"},{"location":"api/#important-notes","text":"Super user metadata - There are 7 nodes that make up the super user metadata. The super user is assigned to 2 User Attributes super_ua1 and super_ua2. These two attributes are assigned to a Policy Class also called super. Super_ua1 is associated with an Object Attribute, super_oa1, which is also assigned to the Policy Class super, with * permissions. This gives any user in super_ua1 all permissions on objects in super_oa1. There is one Object called super assigned to super_oa1. Super_ua2 is associated with super_ua1 with * permissions. This allows the super user to have all permissions on itself as well. Creating a Policy Class - When creating a Policy Class we check if the requesting user has the permission \"create a Policy Class\" on the super object. Policy Class assignments - When a Policy Class is created, an Object Attribute that will represent the Policy Class is also created, and assigned to super_oa1. The representative will be used any time a user is assigning to or deassigning from the Policy Class. This allows us to control who can perform these actions since Policy Classes them selves cannot be assigned or associated to any other nodes.","title":"Important Notes"},{"location":"api/#deployment","text":"","title":"Deployment"},{"location":"api/#run-docker-compose","text":"Build the war file by running mvn clean package install from the project root. This will create pm.war in the project's /target/ directory. Run docker-compose up from the project root to start the docker container.","title":"Run Docker Compose"},{"location":"api/#docker-compose-file","text":"version: '3' services: neo4j: image: neo4j:latest volumes: - $HOME/neo4j/data:/data - $HOME/neo4j/logs:/logs ports: - 7474:7474 - 7687:7687 pm: image: tomcat:8-jre8 volumes: - ./target/pm.war:/usr/local/tomcat/webapps/pm.war ports: - 8080:8080 links: - neo4j The Compose file creates two linked containers. A Neo4j container which is where we will store our access control policy data. We expose the ports 7474 and 7687 to interact with the Neo4j database. The tomcat server that will deploy pm.war .","title":"Docker Compose File"},{"location":"api/#tested-operating-systems","text":"macOS Docker for Mac Windows 7 Docker Toolbox Note : Docker Toolbox is legacy software and handles volumes differently than Docker for Windows/Mac. There is one line in the Docker Compose file that needs to be updated. Create a shared folder in Oracle VirtualBox called /target/ which points to the target folder of the PM project. change this line in the Compose file: ./target/pm.war:/usr/local/tomcat/webapps/pm.war to //target/pm.war:/usr/local/tomcat/webapps/pm.war","title":"Tested Operating Systems"},{"location":"api/#how-to-use-the-api","text":"","title":"How to Use the API"},{"location":"api/#requests","text":"The exposed web services act as an administrative Policy Enforcement Point (PEP). When a request comes in the PEP forwards the request to the PDP, which ensures the requesting user is allowed to carry out the action. This means the PEP always needs to know which user is sending a request. This is tracked using session IDs that represent users who have authenticated successfully with the server. Every endpoint requires this session ID to determine the user. The only API that does not require a session ID is the Sessions API. This API is used to authenticate users and provides the session IDs that will be used in subsequent requests to the Policy Machine. For example, to sign in as the super user: POST /pm/api/sessions Content-Type:application/json { \"username\": \"super\", \"password\": \"super\" } The response from the server will look like: { \"code\": 9000, \"message\": \"success\", \"entity\": \"NEW_SESSION_ID\" } Now the user can pass this session ID to the server for any other calls to the API.","title":"Requests"},{"location":"api/#responses","text":"A response from the Policy Machine will always return an HTTP status code of 200, with more details provided in the body of the response. For example: { \"code\": 9000, \"message\": \"success\", \"entity\": \"return value of the API call\" }","title":"Responses"},{"location":"api/#response-codes","text":"","title":"Response codes"},{"location":"api/#sessions-api","text":"","title":"Sessions API"},{"location":"api/#create-session","text":"Authenticate the provided credentials and return a session ID if successfully authenticated.","title":"Create session"},{"location":"api/#endpoint","text":"POST /pm/api/sessions","title":"Endpoint"},{"location":"api/#parameters","text":"Parameter Required Location Description username required body The username of the user password required body The password of the user","title":"Parameters"},{"location":"api/#example-request","text":"$ curl -X POST {host}:{port}/pm/api/sessions","title":"Example request"},{"location":"api/#example-request-body","text":"{ \"username\": \"super\", \"password\": \"super\" }","title":"Example request body"},{"location":"api/#example-response","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": \"{sessionID}\" }","title":"Example response"},{"location":"api/#delete-session","text":"Delete the session with the given session ID.","title":"Delete session"},{"location":"api/#endpoint_1","text":"DELETE /pm/api/sessions/{sessionID}","title":"Endpoint"},{"location":"api/#example-request_1","text":"$ curl -X DELETE {host}:{port}/pm/api/sessions/{sessionID}","title":"Example request"},{"location":"api/#example-response_1","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": \"session deleted\" }","title":"Example response"},{"location":"api/#get-session-user","text":"Get the ID of the user that corresponds with the provided session ID.","title":"Get session user"},{"location":"api/#endpoint_2","text":"GET /pm/api/sessions/{sessionID}","title":"Endpoint"},{"location":"api/#example-request_2","text":"$ curl {host}:{port}/pm/api/sessions/{sessionID}","title":"Example request"},{"location":"api/#example-response_2","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": 1234 }","title":"Example response"},{"location":"api/#graph-api","text":"","title":"Graph API"},{"location":"api/#get-nodes","text":"Retrieve nodes from the graph. Use query parameters to filter nodes based on name, type, or any other properties nodes may have. The returned set of nodes will only contain those the user, identified by the session parameter, has access to.","title":"Get nodes"},{"location":"api/#endpoint_3","text":"GET /pm/api/graph/nodes","title":"Endpoint"},{"location":"api/#parameters_1","text":"Parameter Required Location Description session true query The ID of the current session. name false query The name of the nodes to search for. type false query The type of the nodes to search for. Important Notes The name and type query parameters are the only preset parameters to search for. It is possible to search for nodes with any property key value pair by including the pair in the query parameters of the request. For example, ?key1=value1&key2=value2 . Only nodes that match every provided property will be returned. To search for all nodes that have a specfic property key but an arbitrary value use the wildcard * . For example, key3=* .","title":"Parameters"},{"location":"api/#example-request_3","text":"$ curl {host}:{port}/pm/api/graph/nodes?session={sessionID}&type=OA","title":"Example request"},{"location":"api/#example-response_3","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"node1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"node2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] }","title":"Example response"},{"location":"api/#create-node","text":"Create a new node in the NGAC graph with the provided name, type, and properties. When creating a Policy Class, leave the baseID parameter empty, as it will be ignored. For all other node type, a base ID is required in order to connect the node to the graph and ensure the calling user (identified by the provided session ID) has the permission to create a node in the base node (check that the user can assign to the base node).","title":"Create node"},{"location":"api/#endpoint_4","text":"POST /pm/api/graph/nodes","title":"Endpoint"},{"location":"api/#parameters_2","text":"Parameter Required Location Description session true query The ID of the current session. parentID false body The ID of the node to assign the new node to. name true body The name of the node. type true body The type of the node. properties true body A map of properties to give the node.","title":"Parameters"},{"location":"api/#example-request_4","text":"$ curl -X POST {host}:{port}/pm/api/graph/nodes?session={sessionID}","title":"Example request"},{"location":"api/#example-request-body_1","text":"{ \"name\": \"newNode\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\", \"key2\": \"value2\" } }","title":"Example request body"},{"location":"api/#example-response_4","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": 12345 }","title":"Example response"},{"location":"api/#get-node","text":"Retrieve the information for a node identified by the given ID.","title":"Get node"},{"location":"api/#endpoint_5","text":"GET /pm/api/graph/nodes/{nodeID}","title":"Endpoint"},{"location":"api/#parameters_3","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to retrieve.","title":"Parameters"},{"location":"api/#example-request_5","text":"$ curl {host}:{port}/pm/api/graph/nodes/12345678?session={sessionID}","title":"Example request"},{"location":"api/#example-response_5","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": { \"id\": 12345678, \"name\": \"newNode\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\", \"key2\": \"value2\" } } }","title":"Example response"},{"location":"api/#update-node","text":"Update the name and/or properties of a node with the given ID. The properties provided in the parameters will overwrite existing properties.","title":"Update node"},{"location":"api/#endpoint_6","text":"UPDATE /pm/api/graph/nodes/{nodeID}","title":"Endpoint"},{"location":"api/#parameters_4","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to update. name false body The updated name. properties false body The properties to override the existing properties of the node.","title":"Parameters"},{"location":"api/#example-request_6","text":"$ curl -X PUT {host}:{port}/pm/api/graph/nodes/12345?session={sessionID}","title":"Example request"},{"location":"api/#example-request-body_2","text":"{ \"name\": \"updated_name\", \"properties\": { \"key3\": \"value3\", } }","title":"Example request body"},{"location":"api/#example-response_6","text":"{ \"code\": 9000, \"message\": \"Node was successfully updated\", \"entity\": null }","title":"Example response"},{"location":"api/#delete-node","text":"Delete the node with the given ID. The calling user must have permission to delete the node in order for the action to successfully be carried out.","title":"Delete node"},{"location":"api/#endpoint_7","text":"DELETE /pm/api/graph/nodes/{nodeID}","title":"Endpoint"},{"location":"api/#parameters_5","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to delete.","title":"Parameters"},{"location":"api/#example-request_7","text":"$ curl -X DELETE {host}:{port}/pm/api/graph/nodes/12345?session={sessionID}","title":"Example request"},{"location":"api/#example-response_7","text":"{ \"code\": 9000, \"message\": \"Node successfully deleted\", \"entity\": null }","title":"Example response"},{"location":"api/#get-node-children","text":"Get the nodes that are assigned to the node with the given ID. The method will return only the children the calling user has access to.","title":"Get node children"},{"location":"api/#endpoint_8","text":"GET /pm/api/graph/nodes/{nodeID}/children","title":"Endpoint"},{"location":"api/#parameters_6","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the children of.","title":"Parameters"},{"location":"api/#example-request_8","text":"$ curl {host}:{port}/pm/api/graph/nodes/{nodeID}/children?session={sessionID}","title":"Example request"},{"location":"api/#example-response_8","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"child1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"child2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] }","title":"Example response"},{"location":"api/#get-node-parents","text":"Get the nodes that a node is assigned to. Only the parents that the calling user has access to will be returned.","title":"Get node parents"},{"location":"api/#endpoint_9","text":"GET /pm/api/graph/nodes/{nodeID}/parents","title":"Endpoint"},{"location":"api/#parameters_7","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the parents of.","title":"Parameters"},{"location":"api/#example-request_9","text":"$ curl {host}:{port}/pm/api/graph/nodes/1234/parents?session={sessionID}","title":"Example request"},{"location":"api/#example-response_9","text":"{ \"code\": 9000, \"message\": \"success\", \"entity\": [ { \"name\": \"parent1\", \"type\": \"OA\", \"properties\": { \"key1\": \"value1\" } }, { \"name\": \"parent2\", \"type\": \"OA\", \"properties\": { \"key2\": \"value2\" } } ] }","title":"Example response"},{"location":"api/#create-assignment","text":"Create an assignment between two nodes. An assignment must not already exist between the nodes, and the types of the nodes must make a valid assignment. child parent PC OA OA, PC UA UA, PC O OA u UA ###### Endpoint POST /pm/api/graph/{child}/assignments/{parent} ###### Parameters Parameter Required --- --- session true child true parent true","title":"Create assignment"},{"location":"api/#example-request_10","text":"$ curl -X POST {host}:{port}/pm/api/graph/child;id=1234;type=OA/assignments/parent;id=4321;type=OA?session={sessionID}","title":"Example request"},{"location":"api/#example-response_10","text":"{ \"code\": 9000, \"message\": \"Assignment successfully created\", \"entity\": null }","title":"Example response"},{"location":"api/#delete-assignment","text":"Delete an assignment between two nodes, as long as the calling user has permissions to do so. If an assignment does not exist between the two nodes, nothing will happen and a success code will be returned.","title":"Delete assignment"},{"location":"api/#endpoint_10","text":"DELETE /pm/api/graph/{childID}/assignments/{parentID}","title":"Endpoint"},{"location":"api/#parameters_8","text":"Parameter | Required | Location | Description | Example ---|---|---|--- session | true | query | The ID of the current session. | child | true | body | The ID of the child node and a martix parameter for the type. | child;id=1234;type=OA parent | true | body | The ID of the parent node and a matrix parameter for the type. | parent;id=4321;type=OA","title":"Parameters"},{"location":"api/#example-request_11","text":"$ curl -X DELETE {host}:{port}/pm/api/graph/child;id=1234;type=OA/assignments/parent;id=4321;type=OA?session={sessionID}","title":"Example request"},{"location":"api/#example-response_11","text":"{ \"code\": 9000, \"message\": \"Assignment successfully deleted\", \"entity\": null }","title":"Example response"},{"location":"api/#get-associations","text":"Get the associations the given node is apart of. The node must exist in the graph. The query parameter type is required and denotes which type of associations to retrieve for the node. Accepted values are source and target . Source will get the associations the given node is the source of. Target will get the associations the given node is a target of.","title":"Get associations"},{"location":"api/#endpoint_11","text":"GET /pm/api/graph/{nodeID}/associations","title":"Endpoint"},{"location":"api/#parameters_9","text":"Parameter Required Location Description session true query The ID of the current session. nodeID true path The ID of the node to get the associations for. type true query Either source or target .","title":"Parameters"},{"location":"api/#example-request_12","text":"$ curl {host}:{port}/pm/api/graph/101?session={sessionID}&type=source","title":"Example request"},{"location":"api/#example-response_12","text":"{ \"1234\": [ \"read\", \"write\" ], \"4321\": [ \"read\" ] }","title":"Example response"},{"location":"api/#create-association","text":"Create an association between a user attribute and a target node. The user attribute and target nodes need to already exist in the graph. The target node can be another user attribute or an object attribute. The target segment of the request url must contain the ID and type of the intended target node.","title":"Create association"},{"location":"api/#endpoint_12","text":"POST /pm/api/graph/{uaID}/associations/{target}","title":"Endpoint"},{"location":"api/#parameters_10","text":"Parameter Required Location Description session true query The ID of the current session. uaID true path The ID of the User Attribute. target true path The target of the association. The ID and Type are required matrix parameters. operations false body The set of operations to give the association.","title":"Parameters"},{"location":"api/#example-request_13","text":"$ curl {host}:{port}/pm/api/graph/1234/associations/target;id=4321;type=OA?session={sessionID}","title":"Example request"},{"location":"api/#example-request-body_3","text":"{ \"operations\": [ \"read\", \"write\" ] }","title":"Example request body"},{"location":"api/#example-response_13","text":"{ \"code\": 9000, \"message\": \"Association successfully created\", \"entity\": null }","title":"Example response"},{"location":"api/#update-association","text":"","title":"Update association"},{"location":"api/#endpoint_13","text":"GET /pm/api/graph/nodes","title":"Endpoint"},{"location":"api/#parameters_11","text":"Parameter Required Location Description session true query The ID of the current session.","title":"Parameters"},{"location":"api/#example-request_14","text":"$ curl {host}:{port}/pm/api/graph/nodes?session={sessionID}","title":"Example request"},{"location":"api/#example-response_14","text":"","title":"Example response"},{"location":"api/#delete-association","text":"","title":"Delete association"},{"location":"api/#endpoint_14","text":"GET /pm/api/graph/nodes","title":"Endpoint"},{"location":"api/#parameters_12","text":"Parameter Required Location Description session true query The ID of the current session.","title":"Parameters"},{"location":"api/#example-request_15","text":"$ curl {host}:{port}/pm/api/graph/nodes?session={sessionID}","title":"Example request"},{"location":"api/#example-response_15","text":"","title":"Example response"},{"location":"examples/","text":"Examples Standalone Examples Below are examples on how to create a NGAC graph and query that graph for access control decisions using the Policy Machine as a Java library. Bank Teller The full code for this example can be found at src/gov/nist/csd/pm/demos/standalone/BankTellerExample.java Example configuration summary Users: u1, u2 An object o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute Access control state: u1 can read and write o1 u2 can read o1 1. Create a new Graph instance. For this example, we'll use the MemGraph which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); 2. Create the user nodes u1 and u2 . long user1ID = graph.createNode(new NodeContext(rand.nextLong(), \"u1\", U, null)); long user2ID = graph.createNode(new NodeContext(rand.nextLong(), \"u2\", U, null)); 3. Create the object, o1 that will be the target of the access queries. long objectID = graph.createNode(new NodeContext(rand.nextLong(), \"o1\", O, null)); 4. Create the RBAC policy class node. long rbacID = graph.createNode(new NodeContext(rand.nextLong(), \"RBAC\", PC, null)); 5. Create an object attribute for the Accounts . long accountsID = graph.createNode(new NodeContext(rand.nextLong(), \"Accounts\", OA, null)); 6. Create the Teller and Auditor user attributes. long tellerID = graph.createNode(new NodeContext(rand.nextLong(), \"Teller\", UA, null)); long auditorID = graph.createNode(new NodeContext(rand.nextLong(), \"Auditor\", UA, null)); 7. Assign the Accounts object attribute to the RBAC policy class node. graph.assign(new NodeContext(accountsID, OA), new NodeContext(rbacID, PC)); 8. Assign the object, o1 , to the Accounts object attribute. graph.assign(new NodeContext(objectID, O), new NodeContext(accountsID, OA)); 9. Assign u1 to the Teller user attribute and u2 to the Auditor user attribute. graph.assign(new NodeContext(user1ID, U), new NodeContext(tellerID, UA)); graph.assign(new NodeContext(user2ID, U), new NodeContext(auditorID, UA)); 10. Create the associations for Teller and Auditor on Account in RBAC. Teller has read and write permissions, while Auditor just has read permissions. graph.associate(new NodeContext(tellerID, UA), new NodeContext(accountsID, OA), new HashSet<>(Arrays.asList(\"r\", \"w\"))); graph.associate(new NodeContext(auditorID, UA), new NodeContext(accountsID, OA), new HashSet<>(Arrays.asList(\"r\"))); 11. Create the Branches policy class. long branchesID = graph.createNode(new NodeContext(rand.nextLong(), \"branches\", PC, null)); 12. Create an object attribute for Branch 1 . long branches1OAID = graph.createNode(new NodeContext(rand.nextLong(), \"branch 1\", OA, null)); 13. Create the Branch 1 user attribute long branches1UAID = graph.createNode(new NodeContext(rand.nextLong(), \"branch 1\", UA, null)); 14. Assign the object, o1 , to the Branch 1 object attribute graph.assign(new NodeContext(objectID, O), new NodeContext(branches1OAID, OA)); 15. Assign the users, u1 and u2 , to the branch 1 user attribute graph.assign(new NodeContext(user1ID, U), new NodeContext(branches1UAID, UA)); graph.assign(new NodeContext(user2ID, U), new NodeContext(branches1UAID, UA)); 16. Create an association between the branch 1 user attribute and the branch 1 object attribute. This will give both users read and write on o1 under the branches policy class. graph.associate(new NodeContext(branches1UAID, UA), new NodeContext(branches1OAID, OA), new HashSet<>(Arrays.asList(\"r\", \"w\"))); 17. Test the configuration using the PReviewDecider implementation of the Decider interface. The constructor for a PReviewDecider receives the graph we created and a list of prohibitions. Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph, null); 18. Check that u1 has read and write permissions on o1 . HashSet<String> permissions = decider.listPermissions(user1ID, 0, objectID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); 19. Check that u1 has read permissions on o1 . permissions = decider.listPermissions(user2ID, 0, objectID); assertTrue(permissions.contains(\"r\")); Below is a visual representation of the graph created in the bank teller example. Employee Record Example configuration summary: Users: bob, alice, charlie The objects are bob's and alice's name, salary, and ssn. All users are assigned to the Staff user attribute The Staff user attribute has read permissions on Public Info, which in this case is names. Charlie has the HR attribute HR has read and write permissions on Salaries and SSNs Bob and Alice have the Grp1Mgr and Grp2Mgr attributes, respectively Grp1Mgr and Grp2Mgr have read permissions on Grp1Salaries and Grp2Salaries, respectively Bob and Alice have read and write permissions on their name and ssn, and read permissions on their salaries. Access control state: Alice can read and write her name and SSN, and read her salary, and the salaries of those in Group 2. Bob can read and write his name and SSN, and read his salary, and salaries of those in Group 1. Charlie can read and write all salaries and SSNs, and read all names. Graph graph = new MemGraph(); // create nodes // object attributes long salariesID = graph.createNode(new NodeContext(rand.nextLong(), \"Salaries\", OA, null)); long ssnsID = graph.createNode(new NodeContext(rand.nextLong(), \"SSNs\", OA, null)); long grp1SalariesID = graph.createNode(new NodeContext(rand.nextLong(), \"Grp1 Salaries\", OA, null)); long grp2SalariesID = graph.createNode(new NodeContext(rand.nextLong(), \"Grp2 Salaries\", OA, null)); long publicID = graph.createNode(new NodeContext(rand.nextLong(), \"Public Info\", OA, null)); long bobRecID = graph.createNode(new NodeContext(rand.nextLong(), \"Bob Record\", OA, null)); long bobRID = graph.createNode(new NodeContext(rand.nextLong(), \"Bob r\", OA, null)); long bobRWID = graph.createNode(new NodeContext(rand.nextLong(), \"Bob r/w\", OA, null)); long aliceRecID = graph.createNode(new NodeContext(rand.nextLong(), \"Alice Record\", OA, null)); long aliceRID = graph.createNode(new NodeContext(rand.nextLong(), \"Alice r\", OA, null)); long aliceRWID = graph.createNode(new NodeContext(rand.nextLong(), \"Alice r/w\", OA, null)); // objects for bob's name, salary, and ssn long bobNameID = graph.createNode(new NodeContext(rand.nextLong(), \"bob name\", O, null)); long bobSalaryID = graph.createNode(new NodeContext(rand.nextLong(), \"bob salary\", O, null)); long bobSSNID = graph.createNode(new NodeContext(rand.nextLong(), \"bob ssn\", O, null)); // objects for alice's name, salary, and ssn long aliceNameID = graph.createNode(new NodeContext(rand.nextLong(), \"alice name\", O, null)); long aliceSalaryID = graph.createNode(new NodeContext(rand.nextLong(), \"alice salary\", O, null)); long aliceSSNID = graph.createNode(new NodeContext(rand.nextLong(), \"alice ssn\", O, null)); // user attributes long hrID = graph.createNode(new NodeContext(rand.nextLong(), \"HR\", UA, null)); long grp1MgrID = graph.createNode(new NodeContext(rand.nextLong(), \"Grp1Mgr\", UA, null)); long grp2MgrID = graph.createNode(new NodeContext(rand.nextLong(), \"Grp2Mgr\", UA, null)); long staffID = graph.createNode(new NodeContext(rand.nextLong(), \"Staff\", UA, null)); long bobUAID = graph.createNode(new NodeContext(rand.nextLong(), \"Bob\", UA, null)); long aliceUAID = graph.createNode(new NodeContext(rand.nextLong(), \"Alice\", UA, null)); // users long bobID = graph.createNode(new NodeContext(rand.nextLong(), \"bob\", U, null)); long aliceID = graph.createNode(new NodeContext(rand.nextLong(), \"alice\", U, null)); long charlieID = graph.createNode(new NodeContext(rand.nextLong(), \"charlie\", U, null)); // policy class long pcID = graph.createNode(new NodeContext(rand.nextLong(), \"Employee Records\", PC, null)); // assignments // assign users to user attributes graph.assign(new NodeContext(charlieID, U), new NodeContext(hrID, UA)); graph.assign(new NodeContext(bobID, U), new NodeContext(grp1MgrID, UA)); graph.assign(new NodeContext(aliceID, U), new NodeContext(grp2MgrID, UA)); graph.assign(new NodeContext(charlieID, U), new NodeContext(staffID, UA)); graph.assign(new NodeContext(bobID, U), new NodeContext(staffID, UA)); graph.assign(new NodeContext(aliceID, U), new NodeContext(staffID, UA)); graph.assign(new NodeContext(bobID, U), new NodeContext(bobUAID, UA)); graph.assign(new NodeContext(aliceID, U), new NodeContext(aliceUAID, UA)); // assign objects to object attributes // salary objects graph.assign(new NodeContext(bobSalaryID, O), new NodeContext(salariesID, OA)); graph.assign(new NodeContext(bobSalaryID, O), new NodeContext(grp1SalariesID, OA)); graph.assign(new NodeContext(bobSalaryID, O), new NodeContext(bobRID, OA)); graph.assign(new NodeContext(aliceSalaryID, O), new NodeContext(salariesID, OA)); graph.assign(new NodeContext(aliceSalaryID, O), new NodeContext(grp2SalariesID, OA)); graph.assign(new NodeContext(aliceSalaryID, O), new NodeContext(aliceRID, OA)); // ssn objects graph.assign(new NodeContext(bobSSNID, O), new NodeContext(ssnsID, OA)); graph.assign(new NodeContext(bobSSNID, O), new NodeContext(bobRWID, OA)); graph.assign(new NodeContext(aliceSSNID, O), new NodeContext(aliceID, OA)); graph.assign(new NodeContext(aliceSSNID, O), new NodeContext(aliceRWID, OA)); // name objects graph.assign(new NodeContext(bobNameID, O), new NodeContext(publicID, OA)); graph.assign(new NodeContext(bobNameID, O), new NodeContext(bobRWID, OA)); graph.assign(new NodeContext(aliceNameID, O), new NodeContext(publicID, OA)); graph.assign(new NodeContext(aliceNameID, O), new NodeContext(aliceRWID, OA)); // bob and alice r/w containers to their records graph.assign(new NodeContext(bobRID, OA), new NodeContext(bobRecID, OA)); graph.assign(new NodeContext(bobRWID, OA), new NodeContext(bobRecID, OA)); graph.assign(new NodeContext(aliceRID, OA), new NodeContext(aliceRecID, OA)); graph.assign(new NodeContext(aliceRWID, OA), new NodeContext(aliceRecID, OA)); // assign object attributes to policy classes graph.assign(new NodeContext(salariesID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(ssnsID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(grp1SalariesID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(grp2SalariesID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(publicID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(bobRecID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(aliceRecID, OA), new NodeContext(pcID, PC)); // associations HashSet<String> rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); HashSet<String> r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(new NodeContext(hrID, UA), new NodeContext(salariesID, OA), rw); graph.associate(new NodeContext(hrID, UA), new NodeContext(ssnsID, OA), rw); graph.associate(new NodeContext(grp1MgrID, UA), new NodeContext(grp1SalariesID, OA), r); graph.associate(new NodeContext(grp2MgrID, UA), new NodeContext(grp2SalariesID, OA), r); graph.associate(new NodeContext(staffID, UA), new NodeContext(publicID, OA), r); graph.associate(new NodeContext(bobUAID, UA), new NodeContext(bobRWID, OA), rw); graph.associate(new NodeContext(bobUAID, UA), new NodeContext(bobRID, OA), r); graph.associate(new NodeContext(aliceUAID, UA), new NodeContext(aliceRWID, OA), rw); graph.associate(new NodeContext(aliceUAID, UA), new NodeContext(aliceRID, OA), r); // test configuration // create a decider // not using prohibitions in this example, so null is passed Decider decider = new PReviewDecider(graph, null); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] HashSet<String> permissions = decider.listPermissions(bobID, 0, bobSSNID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: bob // target: 'bob ssn' // expected: [r] // actual: [r] permissions = decider.listPermissions(bobID, 0, bobSalaryID); assertTrue(permissions.contains(\"r\")); // user: bob // target: 'alice ssn' // expected: [] // actual: [] permissions = decider.listPermissions(bobID, 0, aliceSSNID); assertTrue(permissions.isEmpty()); // user: bob // target: 'alice salary' // expected: [] // actual: [] permissions = decider.listPermissions(bobID, 0, aliceSalaryID); assertTrue(permissions.isEmpty()); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(aliceID, 0, aliceSSNID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: charlie // target: 'alice salary' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(charlieID, 0, aliceSalaryID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); Below is a visual representation of the graph created in the employee record example. REST API Examples Coming soon...","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#standalone-examples","text":"Below are examples on how to create a NGAC graph and query that graph for access control decisions using the Policy Machine as a Java library.","title":"Standalone Examples"},{"location":"examples/#bank-teller","text":"The full code for this example can be found at src/gov/nist/csd/pm/demos/standalone/BankTellerExample.java Example configuration summary Users: u1, u2 An object o1 Two policy classes: RBAC and Branches RBAC o1 is assigned to accounts u1 is a Teller that has read and write permissions on accounts u2 is an Auditor that has read permissions on accounts Branches u1 and u2 are both assigned to the Branch 1 user attribute o1 is assigned to the Branch 1 object attribute the Branch 1 user attribute has read and write permissions on the Branch 1 object attribute Access control state: u1 can read and write o1 u2 can read o1 1. Create a new Graph instance. For this example, we'll use the MemGraph which is an in memory implementation of the Graph interface. Graph graph = new MemGraph(); 2. Create the user nodes u1 and u2 . long user1ID = graph.createNode(new NodeContext(rand.nextLong(), \"u1\", U, null)); long user2ID = graph.createNode(new NodeContext(rand.nextLong(), \"u2\", U, null)); 3. Create the object, o1 that will be the target of the access queries. long objectID = graph.createNode(new NodeContext(rand.nextLong(), \"o1\", O, null)); 4. Create the RBAC policy class node. long rbacID = graph.createNode(new NodeContext(rand.nextLong(), \"RBAC\", PC, null)); 5. Create an object attribute for the Accounts . long accountsID = graph.createNode(new NodeContext(rand.nextLong(), \"Accounts\", OA, null)); 6. Create the Teller and Auditor user attributes. long tellerID = graph.createNode(new NodeContext(rand.nextLong(), \"Teller\", UA, null)); long auditorID = graph.createNode(new NodeContext(rand.nextLong(), \"Auditor\", UA, null)); 7. Assign the Accounts object attribute to the RBAC policy class node. graph.assign(new NodeContext(accountsID, OA), new NodeContext(rbacID, PC)); 8. Assign the object, o1 , to the Accounts object attribute. graph.assign(new NodeContext(objectID, O), new NodeContext(accountsID, OA)); 9. Assign u1 to the Teller user attribute and u2 to the Auditor user attribute. graph.assign(new NodeContext(user1ID, U), new NodeContext(tellerID, UA)); graph.assign(new NodeContext(user2ID, U), new NodeContext(auditorID, UA)); 10. Create the associations for Teller and Auditor on Account in RBAC. Teller has read and write permissions, while Auditor just has read permissions. graph.associate(new NodeContext(tellerID, UA), new NodeContext(accountsID, OA), new HashSet<>(Arrays.asList(\"r\", \"w\"))); graph.associate(new NodeContext(auditorID, UA), new NodeContext(accountsID, OA), new HashSet<>(Arrays.asList(\"r\"))); 11. Create the Branches policy class. long branchesID = graph.createNode(new NodeContext(rand.nextLong(), \"branches\", PC, null)); 12. Create an object attribute for Branch 1 . long branches1OAID = graph.createNode(new NodeContext(rand.nextLong(), \"branch 1\", OA, null)); 13. Create the Branch 1 user attribute long branches1UAID = graph.createNode(new NodeContext(rand.nextLong(), \"branch 1\", UA, null)); 14. Assign the object, o1 , to the Branch 1 object attribute graph.assign(new NodeContext(objectID, O), new NodeContext(branches1OAID, OA)); 15. Assign the users, u1 and u2 , to the branch 1 user attribute graph.assign(new NodeContext(user1ID, U), new NodeContext(branches1UAID, UA)); graph.assign(new NodeContext(user2ID, U), new NodeContext(branches1UAID, UA)); 16. Create an association between the branch 1 user attribute and the branch 1 object attribute. This will give both users read and write on o1 under the branches policy class. graph.associate(new NodeContext(branches1UAID, UA), new NodeContext(branches1OAID, OA), new HashSet<>(Arrays.asList(\"r\", \"w\"))); 17. Test the configuration using the PReviewDecider implementation of the Decider interface. The constructor for a PReviewDecider receives the graph we created and a list of prohibitions. Since no prohibitions are used in this example, we'll pass null. Decider decider = new PReviewDecider(graph, null); 18. Check that u1 has read and write permissions on o1 . HashSet<String> permissions = decider.listPermissions(user1ID, 0, objectID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); 19. Check that u1 has read permissions on o1 . permissions = decider.listPermissions(user2ID, 0, objectID); assertTrue(permissions.contains(\"r\")); Below is a visual representation of the graph created in the bank teller example.","title":"Bank Teller"},{"location":"examples/#employee-record","text":"Example configuration summary: Users: bob, alice, charlie The objects are bob's and alice's name, salary, and ssn. All users are assigned to the Staff user attribute The Staff user attribute has read permissions on Public Info, which in this case is names. Charlie has the HR attribute HR has read and write permissions on Salaries and SSNs Bob and Alice have the Grp1Mgr and Grp2Mgr attributes, respectively Grp1Mgr and Grp2Mgr have read permissions on Grp1Salaries and Grp2Salaries, respectively Bob and Alice have read and write permissions on their name and ssn, and read permissions on their salaries. Access control state: Alice can read and write her name and SSN, and read her salary, and the salaries of those in Group 2. Bob can read and write his name and SSN, and read his salary, and salaries of those in Group 1. Charlie can read and write all salaries and SSNs, and read all names. Graph graph = new MemGraph(); // create nodes // object attributes long salariesID = graph.createNode(new NodeContext(rand.nextLong(), \"Salaries\", OA, null)); long ssnsID = graph.createNode(new NodeContext(rand.nextLong(), \"SSNs\", OA, null)); long grp1SalariesID = graph.createNode(new NodeContext(rand.nextLong(), \"Grp1 Salaries\", OA, null)); long grp2SalariesID = graph.createNode(new NodeContext(rand.nextLong(), \"Grp2 Salaries\", OA, null)); long publicID = graph.createNode(new NodeContext(rand.nextLong(), \"Public Info\", OA, null)); long bobRecID = graph.createNode(new NodeContext(rand.nextLong(), \"Bob Record\", OA, null)); long bobRID = graph.createNode(new NodeContext(rand.nextLong(), \"Bob r\", OA, null)); long bobRWID = graph.createNode(new NodeContext(rand.nextLong(), \"Bob r/w\", OA, null)); long aliceRecID = graph.createNode(new NodeContext(rand.nextLong(), \"Alice Record\", OA, null)); long aliceRID = graph.createNode(new NodeContext(rand.nextLong(), \"Alice r\", OA, null)); long aliceRWID = graph.createNode(new NodeContext(rand.nextLong(), \"Alice r/w\", OA, null)); // objects for bob's name, salary, and ssn long bobNameID = graph.createNode(new NodeContext(rand.nextLong(), \"bob name\", O, null)); long bobSalaryID = graph.createNode(new NodeContext(rand.nextLong(), \"bob salary\", O, null)); long bobSSNID = graph.createNode(new NodeContext(rand.nextLong(), \"bob ssn\", O, null)); // objects for alice's name, salary, and ssn long aliceNameID = graph.createNode(new NodeContext(rand.nextLong(), \"alice name\", O, null)); long aliceSalaryID = graph.createNode(new NodeContext(rand.nextLong(), \"alice salary\", O, null)); long aliceSSNID = graph.createNode(new NodeContext(rand.nextLong(), \"alice ssn\", O, null)); // user attributes long hrID = graph.createNode(new NodeContext(rand.nextLong(), \"HR\", UA, null)); long grp1MgrID = graph.createNode(new NodeContext(rand.nextLong(), \"Grp1Mgr\", UA, null)); long grp2MgrID = graph.createNode(new NodeContext(rand.nextLong(), \"Grp2Mgr\", UA, null)); long staffID = graph.createNode(new NodeContext(rand.nextLong(), \"Staff\", UA, null)); long bobUAID = graph.createNode(new NodeContext(rand.nextLong(), \"Bob\", UA, null)); long aliceUAID = graph.createNode(new NodeContext(rand.nextLong(), \"Alice\", UA, null)); // users long bobID = graph.createNode(new NodeContext(rand.nextLong(), \"bob\", U, null)); long aliceID = graph.createNode(new NodeContext(rand.nextLong(), \"alice\", U, null)); long charlieID = graph.createNode(new NodeContext(rand.nextLong(), \"charlie\", U, null)); // policy class long pcID = graph.createNode(new NodeContext(rand.nextLong(), \"Employee Records\", PC, null)); // assignments // assign users to user attributes graph.assign(new NodeContext(charlieID, U), new NodeContext(hrID, UA)); graph.assign(new NodeContext(bobID, U), new NodeContext(grp1MgrID, UA)); graph.assign(new NodeContext(aliceID, U), new NodeContext(grp2MgrID, UA)); graph.assign(new NodeContext(charlieID, U), new NodeContext(staffID, UA)); graph.assign(new NodeContext(bobID, U), new NodeContext(staffID, UA)); graph.assign(new NodeContext(aliceID, U), new NodeContext(staffID, UA)); graph.assign(new NodeContext(bobID, U), new NodeContext(bobUAID, UA)); graph.assign(new NodeContext(aliceID, U), new NodeContext(aliceUAID, UA)); // assign objects to object attributes // salary objects graph.assign(new NodeContext(bobSalaryID, O), new NodeContext(salariesID, OA)); graph.assign(new NodeContext(bobSalaryID, O), new NodeContext(grp1SalariesID, OA)); graph.assign(new NodeContext(bobSalaryID, O), new NodeContext(bobRID, OA)); graph.assign(new NodeContext(aliceSalaryID, O), new NodeContext(salariesID, OA)); graph.assign(new NodeContext(aliceSalaryID, O), new NodeContext(grp2SalariesID, OA)); graph.assign(new NodeContext(aliceSalaryID, O), new NodeContext(aliceRID, OA)); // ssn objects graph.assign(new NodeContext(bobSSNID, O), new NodeContext(ssnsID, OA)); graph.assign(new NodeContext(bobSSNID, O), new NodeContext(bobRWID, OA)); graph.assign(new NodeContext(aliceSSNID, O), new NodeContext(aliceID, OA)); graph.assign(new NodeContext(aliceSSNID, O), new NodeContext(aliceRWID, OA)); // name objects graph.assign(new NodeContext(bobNameID, O), new NodeContext(publicID, OA)); graph.assign(new NodeContext(bobNameID, O), new NodeContext(bobRWID, OA)); graph.assign(new NodeContext(aliceNameID, O), new NodeContext(publicID, OA)); graph.assign(new NodeContext(aliceNameID, O), new NodeContext(aliceRWID, OA)); // bob and alice r/w containers to their records graph.assign(new NodeContext(bobRID, OA), new NodeContext(bobRecID, OA)); graph.assign(new NodeContext(bobRWID, OA), new NodeContext(bobRecID, OA)); graph.assign(new NodeContext(aliceRID, OA), new NodeContext(aliceRecID, OA)); graph.assign(new NodeContext(aliceRWID, OA), new NodeContext(aliceRecID, OA)); // assign object attributes to policy classes graph.assign(new NodeContext(salariesID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(ssnsID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(grp1SalariesID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(grp2SalariesID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(publicID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(bobRecID, OA), new NodeContext(pcID, PC)); graph.assign(new NodeContext(aliceRecID, OA), new NodeContext(pcID, PC)); // associations HashSet<String> rw = new HashSet<>(Arrays.asList(\"r\", \"w\")); HashSet<String> r = new HashSet<>(Arrays.asList(\"r\")); graph.associate(new NodeContext(hrID, UA), new NodeContext(salariesID, OA), rw); graph.associate(new NodeContext(hrID, UA), new NodeContext(ssnsID, OA), rw); graph.associate(new NodeContext(grp1MgrID, UA), new NodeContext(grp1SalariesID, OA), r); graph.associate(new NodeContext(grp2MgrID, UA), new NodeContext(grp2SalariesID, OA), r); graph.associate(new NodeContext(staffID, UA), new NodeContext(publicID, OA), r); graph.associate(new NodeContext(bobUAID, UA), new NodeContext(bobRWID, OA), rw); graph.associate(new NodeContext(bobUAID, UA), new NodeContext(bobRID, OA), r); graph.associate(new NodeContext(aliceUAID, UA), new NodeContext(aliceRWID, OA), rw); graph.associate(new NodeContext(aliceUAID, UA), new NodeContext(aliceRID, OA), r); // test configuration // create a decider // not using prohibitions in this example, so null is passed Decider decider = new PReviewDecider(graph, null); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] HashSet<String> permissions = decider.listPermissions(bobID, 0, bobSSNID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: bob // target: 'bob ssn' // expected: [r] // actual: [r] permissions = decider.listPermissions(bobID, 0, bobSalaryID); assertTrue(permissions.contains(\"r\")); // user: bob // target: 'alice ssn' // expected: [] // actual: [] permissions = decider.listPermissions(bobID, 0, aliceSSNID); assertTrue(permissions.isEmpty()); // user: bob // target: 'alice salary' // expected: [] // actual: [] permissions = decider.listPermissions(bobID, 0, aliceSalaryID); assertTrue(permissions.isEmpty()); // user: bob // target: 'bob ssn' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(aliceID, 0, aliceSSNID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); // user: charlie // target: 'alice salary' // expected: [r, w] // actual: [r, w] permissions = decider.listPermissions(charlieID, 0, aliceSalaryID); assertTrue(permissions.contains(\"r\")); assertTrue(permissions.contains(\"w\")); Below is a visual representation of the graph created in the employee record example.","title":"Employee Record"},{"location":"examples/#rest-api-examples","text":"Coming soon...","title":"REST API Examples"},{"location":"getting-started/","text":"Getting Started Standalone Java Libraries The REST API provides tools to create NGAC aware applications but requires a certain level of already developed infrastructure to really be useful. If you are looking to just experiment with NGAC graphs and use cases, you can use the Policy Decision Point (PDP), Event Processing Point (EPP), and the Policy Access Point (PAP) packages to test different NGAC policy configurations in your own environments. Build Policy Machine JAR Library In pom.xml change <packaging>war</packaging> to <packaging>jar</packaging> . Run mvn package from the project root. pm.jar will be created in /target/. Add pm.jar to your classpath. Examples can be found below and in demos Example This is an example of building a simple graph, with one of each type of node. We will use the listPermissions function to compute all the permissions u1 has on o1 . // create a new in memory graph Graph graph = new MemGraph(); // create a node for each type long pc1ID = graph.createNode(new NodeContext(1, \"pc1\", PC, NodeUtils.toProperties(\"key1\", \"value1\"))); long oa1ID = graph.createNode(new NodeContext(2, \"oa1\", OA, NodeUtils.toProperties(\"key1\", \"value1\"))); long o1ID = graph.createNode(new NodeContext(3, \"o1\", O, NodeUtils.toProperties(\"key1\", \"value1\"))); long ua1ID = graph.createNode(new NodeContext(4, \"ua1\", UA, NodeUtils.toProperties(\"key1\", \"value1\"))); long u1ID = graph.createNode(new NodeContext(5, \"u1\", U, NodeUtils.toProperties(\"key1\", \"value1\"))); // create assignments graph.assign(new NodeContext(o1ID, O), new NodeContext(oa1ID, OA)); graph.assign(new NodeContext(oaID1, OA), new NodeContext(pc1ID, PC)); graph.assign(new NodeContext(u1ID, U), new NodeContext(ua1ID, UA)); graph.assign(new NodeContext(ua1ID, UA), new NodeContext(pc1ID, PC)); // create an association graph.associate(new NodeContext(ua1ID, UA), new NodeContext(oa1ID, OA), new HashSet<>(Arrays.asList(\"read\", \"write\"))); // create a prohibition for u1 on oa1 Prohibition prohibition = new Prohibition(); prohibition.setName(\"test_deny\"); prohibition.setSubject(new ProhibitionSubject(u1, ProhibitionSubjectType.U)); prohibition.setIntersection(false); prohibition.setOperations(new HashSet<>(Arrays.asList(\"read\"))); prohibition.addNode(new ProhibitionNode(oa1, false)); // create a new policy decider with the in memory graph and a list of prohibitions Decider decider = new PReviewDecider(graph, Arrays.asList(prohibition)); // print the list of permissions that u1 has on o1 System.out.println(decider.listPermissions(u1, NO_PROCESS, o1));// print [\"read\", \"write\"]","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#standalone-java-libraries","text":"The REST API provides tools to create NGAC aware applications but requires a certain level of already developed infrastructure to really be useful. If you are looking to just experiment with NGAC graphs and use cases, you can use the Policy Decision Point (PDP), Event Processing Point (EPP), and the Policy Access Point (PAP) packages to test different NGAC policy configurations in your own environments.","title":"Standalone Java Libraries"},{"location":"getting-started/#build-policy-machine-jar-library","text":"In pom.xml change <packaging>war</packaging> to <packaging>jar</packaging> . Run mvn package from the project root. pm.jar will be created in /target/. Add pm.jar to your classpath. Examples can be found below and in demos","title":"Build Policy Machine JAR Library"},{"location":"getting-started/#example","text":"This is an example of building a simple graph, with one of each type of node. We will use the listPermissions function to compute all the permissions u1 has on o1 . // create a new in memory graph Graph graph = new MemGraph(); // create a node for each type long pc1ID = graph.createNode(new NodeContext(1, \"pc1\", PC, NodeUtils.toProperties(\"key1\", \"value1\"))); long oa1ID = graph.createNode(new NodeContext(2, \"oa1\", OA, NodeUtils.toProperties(\"key1\", \"value1\"))); long o1ID = graph.createNode(new NodeContext(3, \"o1\", O, NodeUtils.toProperties(\"key1\", \"value1\"))); long ua1ID = graph.createNode(new NodeContext(4, \"ua1\", UA, NodeUtils.toProperties(\"key1\", \"value1\"))); long u1ID = graph.createNode(new NodeContext(5, \"u1\", U, NodeUtils.toProperties(\"key1\", \"value1\"))); // create assignments graph.assign(new NodeContext(o1ID, O), new NodeContext(oa1ID, OA)); graph.assign(new NodeContext(oaID1, OA), new NodeContext(pc1ID, PC)); graph.assign(new NodeContext(u1ID, U), new NodeContext(ua1ID, UA)); graph.assign(new NodeContext(ua1ID, UA), new NodeContext(pc1ID, PC)); // create an association graph.associate(new NodeContext(ua1ID, UA), new NodeContext(oa1ID, OA), new HashSet<>(Arrays.asList(\"read\", \"write\"))); // create a prohibition for u1 on oa1 Prohibition prohibition = new Prohibition(); prohibition.setName(\"test_deny\"); prohibition.setSubject(new ProhibitionSubject(u1, ProhibitionSubjectType.U)); prohibition.setIntersection(false); prohibition.setOperations(new HashSet<>(Arrays.asList(\"read\"))); prohibition.addNode(new ProhibitionNode(oa1, false)); // create a new policy decider with the in memory graph and a list of prohibitions Decider decider = new PReviewDecider(graph, Arrays.asList(prohibition)); // print the list of permissions that u1 has on o1 System.out.println(decider.listPermissions(u1, NO_PROCESS, o1));// print [\"read\", \"write\"]","title":"Example"},{"location":"links/","text":"","title":"Links"},{"location":"obligations/","text":"1. Obligations Overview 2. Obligation YAML Start an Obligation YAML script with: obligations: - obligation: ... - obligation: There can be zero or more obligations per file, each one created with obligation: Obligation label: rules: - rule: ... - rule: label - A label to give the obligation. If one is not specified, then a random value will be used. rules - Contains a set of zero or more rules. Rule rule: label: event: response: label - A label to give the rule. If one is not specified a random value will be used. event - The event pattern for this rule. response - The response to the event. Common Elements First, some common elements that will be used throughout this specification. user user: name: properties: func_...: Specifies a User with the given name and properties. It is possible to specify a group of users that share a property by omitting the name field and adding a property that they share. A function can be used to specify a user so long as the function returns a user or set of users. Example: user: name: \"aUser\" user: # all users who have the property key=sharedProperty properties: key: \"sharedProperty\" ### user: func_current_user: user_attribute user_attribute: name: properties: func_...: Specifies a User Attribute with the given name and properties. If multiple User Attributes share a name, then this element will represent all of those User Attributes at processing time. Use the properties field to differentiate User Attributes with the same name. A function can be used to specify a user_attribute so long as the function returns a user attribute or a set of user attributes. Example: user_attribute: name: \"uaName\" properties: key: \"value\" ### user_attribute: func_uattrs_of_current_user: function A function refers to a previously defined function that is supported by the Policy Machine Event Processing Point (EPP). A list of valid functions, as well as tutorial on how to add functions can be found here . Every function must have the prefix func_ this will allow the parser to know it's found a function, and to look for a way to parse it. Example func_FUNCTION_NAME: - arg1_name: \"foo\" - arg2_name: func_ANOTHER_FUNCTION: - arg3_name: user_attribute: name: \"uaName\" Event Pattern event: subject: policy_class: operations: target: The Event Pattern specifies an event involving the policy elements of the Policy Machine. An example is a user performing a read operation on an object. This is called an access event, which is the primary focus of obligations as described in the NGAC standard. An access event has four components: The subject, policy class, operations, and target. All of these are optional, but omitting them will have different consequences, which will be described in the sections below. While the Policy Machine focuses on access events, it is possible to extend the functionality of the Event Pattern to other events such as time. The section How to Extend the Event Pattern section provides a tutorial on how this is possible with the Policy Machine. Subject subject: user: any_user: process: The subject specification can be a user, any user, any user from a set of users and/or user attributes, or a process. If the subject is omitted than all events will match this component of an access event. user See user any_user - user: - user_attribute: - func_...: If left empty, this event pattern will match any user. The any_user element also accepts an array of user , user_attribute , and func_... . Example: any_user: # any user ### any_user: # any user in UAttr123 and user123 - user_attribute: name: \"UAttr123\" properties: key: \"value\" - user: name: \"user123\" ### any_user: func_a_function: # a function that returns a set of entities process process: # can be a string value fun...: # or it can be a function A process is optional, and if omitted than it will be ignored. A process can be a string value (ex: 'a_process_id') or it an be a function such as func_current_process . If the process element is present but is empty than any process will match this pattern. Example: process: \"a_process_id\" # pattern matches the process with \"a_process_id\" as it's ID. ### process: # any event with a process ID present ### process: func_current_process: Policy Class policy_class: name: any: each: The policy class specification can specify a particular policy class with a given name, any policy class, any policy class from a set, all policy classes from a set, or all policy classes. Example policy_class: # policy class PC1 name: \"PC1\" ### policy_class: # any policy class any: ### policy_class: # PC1 or PC2 any: - \"PC1\" - \"PC2\" ### policy_class: # PC1 and PC2 each: - \"PC1\" - \"PC2\" ### policy_class: # all policy classes Operations operations: - \"operation_name\" The operations specification is just a string array of operation names. If the array is not empty than any event with any of the listed operations will match this component of the pattern. If the array is empty than any operation will match this pattern. Example: operations: - \"read\" - \"write\" Target target: policy_element: - policy_element: in: The target specification can be a specific policy element, any policy element, any policy element that is contained in other policy elements, or any policy element from a set of policy elements. All of these elements are optional, and if all are omitted then any event will match this component of the pattern. There are two means by which to express the target of an event. The first is by using policy_element and in to express the target policy element(s) and optionally which containers they are assigned to. The second us by using an array of policy_element . In this case an event will match this component of the pattern if the target of the event exists in the array of policy elements. Mixing these two cases will cause a parsing error. Policy Element policy_element: name: type: properties: A policy element can be a user, user attribute, object, or object attribute. If more than one policy element matches the given parameters, than the policy element component will be a set of elements. If the element is empty, then any element will match this component of the target specification. In in: any: - policy_element: each: - policy_element: The in clause of the policy element specification accepts any or each . Both accept arrays, and will match an event if the target specification policy element is in any/each of the listed policy elements. Examples # any example target: # same as saying \"any element that is assigned to pe1 and/or pe2\" policy_element: # any policy element in: # the policy_element is in pe1 AND/OR pe2 any: - policy_element: name: \"pe1\" type: \"OA\" - policy_element: name: \"pe2\" type: \"OA\" ### # each example target: # same as saying \"any element that is assigned to pe1 and pe2\"\" policy_element: # any policy element in: # the policy element is in pe1 AND pe2 each: - policy_element: name: \"pe1\" type: \"OA\" - policy_element: name: \"pe2\" type: \"OA\" ### # array example target: # same as saying \"pe1 or pe2\" - policy_element: name: \"pe1\" - policy_element: name: \"pe2\" Functions Predefined Functions current_user current_process How to add a function How to Extend the Event Pattern","title":"1. Obligations Overview"},{"location":"obligations/#1-obligations-overview","text":"","title":"1. Obligations Overview"},{"location":"obligations/#2-obligation-yaml","text":"Start an Obligation YAML script with: obligations: - obligation: ... - obligation: There can be zero or more obligations per file, each one created with obligation:","title":"2. Obligation YAML"},{"location":"obligations/#obligation","text":"label: rules: - rule: ... - rule: label - A label to give the obligation. If one is not specified, then a random value will be used. rules - Contains a set of zero or more rules.","title":"Obligation"},{"location":"obligations/#rule","text":"rule: label: event: response: label - A label to give the rule. If one is not specified a random value will be used. event - The event pattern for this rule. response - The response to the event.","title":"Rule"},{"location":"obligations/#common-elements","text":"First, some common elements that will be used throughout this specification.","title":"Common Elements"},{"location":"obligations/#user","text":"user: name: properties: func_...: Specifies a User with the given name and properties. It is possible to specify a group of users that share a property by omitting the name field and adding a property that they share. A function can be used to specify a user so long as the function returns a user or set of users. Example: user: name: \"aUser\" user: # all users who have the property key=sharedProperty properties: key: \"sharedProperty\" ### user: func_current_user:","title":"user"},{"location":"obligations/#user_attribute","text":"user_attribute: name: properties: func_...: Specifies a User Attribute with the given name and properties. If multiple User Attributes share a name, then this element will represent all of those User Attributes at processing time. Use the properties field to differentiate User Attributes with the same name. A function can be used to specify a user_attribute so long as the function returns a user attribute or a set of user attributes. Example: user_attribute: name: \"uaName\" properties: key: \"value\" ### user_attribute: func_uattrs_of_current_user:","title":"user_attribute"},{"location":"obligations/#function","text":"A function refers to a previously defined function that is supported by the Policy Machine Event Processing Point (EPP). A list of valid functions, as well as tutorial on how to add functions can be found here . Every function must have the prefix func_ this will allow the parser to know it's found a function, and to look for a way to parse it. Example func_FUNCTION_NAME: - arg1_name: \"foo\" - arg2_name: func_ANOTHER_FUNCTION: - arg3_name: user_attribute: name: \"uaName\"","title":"function"},{"location":"obligations/#event-pattern","text":"event: subject: policy_class: operations: target: The Event Pattern specifies an event involving the policy elements of the Policy Machine. An example is a user performing a read operation on an object. This is called an access event, which is the primary focus of obligations as described in the NGAC standard. An access event has four components: The subject, policy class, operations, and target. All of these are optional, but omitting them will have different consequences, which will be described in the sections below. While the Policy Machine focuses on access events, it is possible to extend the functionality of the Event Pattern to other events such as time. The section How to Extend the Event Pattern section provides a tutorial on how this is possible with the Policy Machine.","title":"Event Pattern"},{"location":"obligations/#subject","text":"subject: user: any_user: process: The subject specification can be a user, any user, any user from a set of users and/or user attributes, or a process. If the subject is omitted than all events will match this component of an access event.","title":"Subject"},{"location":"obligations/#user_1","text":"See user","title":"user"},{"location":"obligations/#any_user","text":"- user: - user_attribute: - func_...: If left empty, this event pattern will match any user. The any_user element also accepts an array of user , user_attribute , and func_... . Example: any_user: # any user ### any_user: # any user in UAttr123 and user123 - user_attribute: name: \"UAttr123\" properties: key: \"value\" - user: name: \"user123\" ### any_user: func_a_function: # a function that returns a set of entities","title":"any_user"},{"location":"obligations/#process","text":"process: # can be a string value fun...: # or it can be a function A process is optional, and if omitted than it will be ignored. A process can be a string value (ex: 'a_process_id') or it an be a function such as func_current_process . If the process element is present but is empty than any process will match this pattern. Example: process: \"a_process_id\" # pattern matches the process with \"a_process_id\" as it's ID. ### process: # any event with a process ID present ### process: func_current_process:","title":"process"},{"location":"obligations/#policy-class","text":"policy_class: name: any: each: The policy class specification can specify a particular policy class with a given name, any policy class, any policy class from a set, all policy classes from a set, or all policy classes. Example policy_class: # policy class PC1 name: \"PC1\" ### policy_class: # any policy class any: ### policy_class: # PC1 or PC2 any: - \"PC1\" - \"PC2\" ### policy_class: # PC1 and PC2 each: - \"PC1\" - \"PC2\" ### policy_class: # all policy classes","title":"Policy Class"},{"location":"obligations/#operations","text":"operations: - \"operation_name\" The operations specification is just a string array of operation names. If the array is not empty than any event with any of the listed operations will match this component of the pattern. If the array is empty than any operation will match this pattern. Example: operations: - \"read\" - \"write\"","title":"Operations"},{"location":"obligations/#target","text":"target: policy_element: - policy_element: in: The target specification can be a specific policy element, any policy element, any policy element that is contained in other policy elements, or any policy element from a set of policy elements. All of these elements are optional, and if all are omitted then any event will match this component of the pattern. There are two means by which to express the target of an event. The first is by using policy_element and in to express the target policy element(s) and optionally which containers they are assigned to. The second us by using an array of policy_element . In this case an event will match this component of the pattern if the target of the event exists in the array of policy elements. Mixing these two cases will cause a parsing error.","title":"Target"},{"location":"obligations/#policy-element","text":"policy_element: name: type: properties: A policy element can be a user, user attribute, object, or object attribute. If more than one policy element matches the given parameters, than the policy element component will be a set of elements. If the element is empty, then any element will match this component of the target specification.","title":"Policy Element"},{"location":"obligations/#in","text":"in: any: - policy_element: each: - policy_element: The in clause of the policy element specification accepts any or each . Both accept arrays, and will match an event if the target specification policy element is in any/each of the listed policy elements.","title":"In"},{"location":"obligations/#examples","text":"# any example target: # same as saying \"any element that is assigned to pe1 and/or pe2\" policy_element: # any policy element in: # the policy_element is in pe1 AND/OR pe2 any: - policy_element: name: \"pe1\" type: \"OA\" - policy_element: name: \"pe2\" type: \"OA\" ### # each example target: # same as saying \"any element that is assigned to pe1 and pe2\"\" policy_element: # any policy element in: # the policy element is in pe1 AND pe2 each: - policy_element: name: \"pe1\" type: \"OA\" - policy_element: name: \"pe2\" type: \"OA\" ### # array example target: # same as saying \"pe1 or pe2\" - policy_element: name: \"pe1\" - policy_element: name: \"pe2\"","title":"Examples"},{"location":"obligations/#functions","text":"","title":"Functions"},{"location":"obligations/#predefined-functions","text":"current_user current_process","title":"Predefined Functions"},{"location":"obligations/#how-to-add-a-function","text":"","title":"How to add a function"},{"location":"obligations/#how-to-extend-the-event-pattern","text":"","title":"How to Extend the Event Pattern"}]}